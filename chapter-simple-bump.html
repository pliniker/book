<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bump allocation - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html" class="active"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-design.html"><strong aria-hidden="true">4.8.</strong> Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-design.html"><strong aria-hidden="true">4.9.</strong> Compiler: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-impl.html"><strong aria-hidden="true">4.10.</strong> Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.11.</strong> TODO - Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.</strong> Advanced garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.1.</strong> TODO - ?</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.</strong> Full Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.1.</strong> TODO - ?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#bump-allocation" id="bump-allocation">Bump allocation</a></h1>
<p>Now that we can get blocks of raw memory, we need to write objects into it. The
simplest way to do this is to write objects into a block one after the other
in consecutive order. This is bump allocation - we have a pointer, the bump
pointer, which points at the space in the block after the last object that
was written. When the next object is written, the bump pointer is incremented
to point to the space after <em>that</em> object <sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>We will used a fixed power-of-two block size. The benefit of this is that
given a pointer to an object, by zeroing the bits of the pointer that represent
the block size, the result points to the beginning of the block. This will
be useful later when implementing garbage collection.</p>
<p>Our block size will be 32k, a reasonably optimal size arrived at in the
original <a href="http://www.cs.utexas.edu/users/speedway/DaCapo/papers/immix-pldi-2008.pdf">Immix</a> paper. This size can be any power of two though and
different use cases may show different optimal sizes.</p>
<pre><code class="language-rust ignore">pub const BLOCK_SIZE_BITS: usize = 15;
pub const BLOCK_SIZE: usize = 1 &lt;&lt; BLOCK_SIZE_BITS;
</code></pre>
<p>Next, we'll define a struct that wraps the block with a bump pointer and other
metadata.</p>
<pre><code class="language-rust ignore">pub struct BumpBlock {
    cursor: usize,
    limit: usize,
    block: Block,
    meta: Box&lt;BlockMeta&gt;,
}
</code></pre>
<h2><a class="header" href="#bump-allocation-basics" id="bump-allocation-basics">Bump allocation basics</a></h2>
<p>In this struct definition, there are two members that we are interested in
for this section. The other two, <code>limit</code> and <code>meta</code>, will be discussed in the
next section.</p>
<ul>
<li><code>cursor</code>: this is the bump pointer. In our implementation it is the index
into the block where the next object can be written.</li>
<li><code>block</code>: this is the <code>Block</code> itself in which objects will be written.</li>
</ul>
<p>For this bump allocation function, the <code>alloc_size</code> parameter should be a number
of bytes of memory requested. We'll assume that the value provided is equivalent
to an exact number of words so that we don't end up with badly aligned object
placement.</p>
<pre><code class="language-rust ignore">impl BumpBlock {
    pub fn inner_alloc(&amp;mut self, alloc_size: usize) -&gt; Option&lt;*const u8&gt; {
        let next_bump = self.cursor + alloc_size;

        if next_bump &gt; constants::BLOCK_SIZE {
            None
        } else {
            let offset = self.cursor;
            self.cursor = next_bump;
            unsafe { Some(self.block.as_ptr().add(offset) as *const u8) }
        }
    }
}
</code></pre>
<p>In this overly simplistic initial implementation, allocation will simply return
<code>None</code> if the block is full. If there <em>is</em> space, it will be returned as a
<code>Some(*const u8)</code> pointer.</p>
<p>Note that this function does not <em>write</em> the object to memory, it merely
returns a pointer to an available space.  Writing the object will simply
require invoking the <code>std::ptr::write</code> function. We will do that in a separate
module but for completeness of this chapter, this might look something like:</p>
<pre><code class="language-rust ignore">use std::ptr::write;

unsafe fn write&lt;T&gt;(dest: *const u8, object: T) {
    write(dest as *mut T, object);
}
</code></pre>
<h2><a class="header" href="#some-time-passes" id="some-time-passes">Some time passes...</a></h2>
<p>After allocating and freeing objects, we will have gaps between objects in a
block that can be reused. The above bump allocation algorithm is unaware of
these gaps so we'll have to modify it before it can allocate into fragmented
blocks.</p>
<p>Remember that in Immix, only whole lines are considered for reuse. To recap,
a block is divided into lines. When objects are marked as live, so are the
lines that an object occupies. Therefore, only lines that are <em>not</em> marked
as live are usable for allocation into.</p>
<p>We'll need a data structure to represent this. we'll call it <code>BlockMeta</code>,
but first some constants that we need in order to know how big a line is
and how many are in a block:</p>
<pre><code class="language-rust ignore">pub const LINE_SIZE_BITS: usize = 7;
pub const LINE_SIZE: usize = 1 &lt;&lt; LINE_SIZE_BITS;
pub const LINE_COUNT: usize = BLOCK_SIZE / LINE_SIZE;
</code></pre>
<p>And now the definition of <code>BlockMeta</code>:</p>
<pre><code class="language-rust ignore">pub struct BlockMeta {
    line_mark: [bool; constants::LINE_COUNT],
    block_mark: bool,
}
</code></pre>
<ul>
<li><code>line_mark</code> is an array of boolean flags, one for each line in a
block, to indicate whether it has been marked or not.</li>
<li><code>block_mark</code> simply says whether the entire block has
marked objects in it. If this is ever <code>false</code>, the entire block can be
deallocated.</li>
</ul>
<p>This struct contains one function we will study:</p>
<pre><code class="language-rust ignore">    pub fn find_next_available_hole(&amp;self, starting_at: usize) -&gt; Option&lt;(usize, usize)&gt; {
        let mut count = 0;
        let mut start: Option&lt;usize&gt; = None;
        let mut stop: usize = 0;

        let starting_line = starting_at / constants::LINE_SIZE;

        for (index, marked) in self.line_mark[starting_line..].iter().enumerate() {
            let abs_index = starting_line + index;

            // count unmarked lines
            if !*marked {
                count += 1;

                // if this is the first line in a hole (and not the zeroth line), consider it
                // conservatively marked and skip to the next line
                if count == 1 &amp;&amp; abs_index &gt; 0 {
                    continue;
                }

                // record the first hole index
                if start.is_none() {
                    start = Some(abs_index);
                }

                // stop is now at the end of this line
                stop = abs_index + 1;
            }

            // if we reached a marked line or the end of the block, see if we have
            // a valid hole to work with
            if count &gt; 0 &amp;&amp; (*marked || stop &gt;= constants::LINE_COUNT) {
                if let Some(start) = start {
                    let cursor = start * constants::LINE_SIZE;
                    let limit = stop * constants::LINE_SIZE;

                    return Some((cursor, limit));
                }
            }

            // if this line is marked and we didn't return a new cursor/limit pair by now,
            // reset the hole state
            if *marked {
                count = 0;
                start = None;
            }
        }

        None
    }
</code></pre>
<ul>
<li>The input to this function, <code>starting_at</code>, is the offset into the block at
which we are looking for a large enough consecutive set of unmarked lines
to write an object into. The value passed in will be the bump pointer, of
course, since that is where we last successfully wrote to the block at.</li>
<li>The return value is <code>None</code> if no unmarked lines are found.</li>
<li>If there <em>are</em> unmarked lines after the <code>starting_at</code> point, the return
value will be a pair of numbers - <code>(cursor, limit)</code> - where <code>cursor</code> will
be the new bump pointer value and <code>limit</code> will be the upper bound of the
available hole.</li>
</ul>
<p>The first thing this function does is convert from block byte offset math
to line count math:</p>
<pre><code class="language-rust ignore">         let starting_line = starting_at / constants::LINE_SIZE;
</code></pre>
<p>And then iterate over the lines starting with the line that the requested
byte offset starting point corresponds with:</p>
<pre><code class="language-rust ignore">         for (index, marked) in self.line_mark[starting_line..].iter().enumerate() {
             let abs_index = starting_line + index;
</code></pre>
<p>We're looking for unmarked lines to allocate into, so we'll count how many
we get so we can later calculate the start and end offsets of a hole:</p>
<pre><code class="language-rust ignore">            // count unmarked lines
            if !*marked {
                count += 1;
</code></pre>
<p>Up next are a couple lines of code that need longer explanation:</p>
<pre><code class="language-rust ignore">                if count == 1 &amp;&amp; abs_index &gt; 0 {
                    continue;
                }
</code></pre>
<p>The Immix authors found that marking <em>every</em> line that contains a live object
could be expensive. For example, many small objects might cross line boundaries,
requiring two lines to be marked as live. This would require looking up the
object size and calculating whether the object crosses the boundary into the
next line. To save CPU cycles, they simplified the algorithm by saying that
any object that fits in a line <em>might</em> cross into the next line so we will
conservatively <em>consider</em> the next line marked just in case. This sped up
marking at little fragmentation expense.</p>
<p>So the three lines of code above simply say: if we've so-far only found one
unmarked block, consider that it might be a conservatively-marked line and
ignore it.</p>
<p>Once that condition has passed and we're clear of any conservatively-marked
line, we can consider the next unmarked line as totally available. Here we
save the index of this line in the variable <code>start</code>:</p>
<pre><code class="language-rust ignore">                if start.is_none() {
                    start = Some(abs_index);
                }
</code></pre>
<p>Now we have a starting line for the overall hole between marked objects. Next
we'll close the <code>if *marked</code> scope by setting the end of the hole:</p>
<pre><code class="language-rust ignore">                stop = abs_index + 1;
            }
</code></pre>
<p>The loop will continue and while there are consecutive unmarked lines, <code>stop</code>
will continue to be updated to a later line boundary.</p>
<p>As soon as we hit a marked line or the end of the block, and we have a nonzero
number of unmarked lines, we'll test whether we have a valid hole to allocate
into:</p>
<pre><code class="language-rust ignore">            if count &gt; 0 &amp;&amp; (*marked || stop &gt;= constants::LINE_COUNT) {
                if let Some(start) = start {
                    let cursor = start * constants::LINE_SIZE;
                    let limit = stop * constants::LINE_SIZE;

                    return Some((cursor, limit));
                }
            }
</code></pre>
<p>Here we convert line-based math back into block byte-offset values and return
the new bump-pointer and upper limit.</p>
<p>Otherwise, if the above conditions failed but we've still reached a marked
line, reset the state:</p>
<pre><code class="language-rust ignore">            if *marked {
                count = 0;
                start = None;
            }
</code></pre>
<p>Finally, if the whole loop terminates without returning a new
<code>Some((cursor, limit))</code> pair, return <code>None</code> as our way of saying this block
has no usable holes to allocate into.</p>
<p>We'll return to the <code>BumpBlock::inner_alloc()</code> function now to make use of
<code>BlockMeta</code> and it's hole finding operation.</p>
<p>The <code>BumpBlock</code> struct contains two more members: <code>limit</code> and <code>meta</code>. These
should now be obvious - <code>limit</code> is the known byte offset limit into which
we can allocate, and <code>meta</code> is the <code>BlockMeta</code> instance associated with the
block.</p>
<p>We need to update <code>inner_alloc()</code> with a new condition:</p>
<ul>
<li>the size being requested must fit between <code>self.cursor</code> and <code>self.limit</code></li>
</ul>
<p>(Note that for a fresh, new block, <code>self.limit</code> is set to the block size.)</p>
<p>If the above condition is not met, we will call
<code>BlockMeta::find_next_available_hole()</code> to get a new <code>cursor</code> and <code>limit</code>
to try, and repeat that until we've either <em>found</em> a big enough hole or
reached the end of the block, exhausting our options.</p>
<p>The new definition of <code>BumpBlock::inner_alloc()</code> reads as follows:</p>
<pre><code class="language-rust ignore">    pub fn inner_alloc(&amp;mut self, alloc_size: usize) -&gt; Option&lt;*const u8&gt; {
        let next_bump = self.cursor + alloc_size;

        if next_bump &gt; self.limit {
            if self.limit &lt; constants::BLOCK_SIZE {
                if let Some((cursor, limit)) = self.meta.find_next_available_hole(self.limit) {
                    self.cursor = cursor;
                    self.limit = limit;
                    return self.inner_alloc(alloc_size);
                }
            }

            None
        } else {
            let offset = self.cursor;
            self.cursor = next_bump;
            unsafe { Some(self.block.as_ptr().add(offset) as *const u8) }
        }
    }
</code></pre>
<p>and as you can see, this implementation is recursive.</p>
<h2><a class="header" href="#wrapping-this-up" id="wrapping-this-up">Wrapping this up</a></h2>
<p>At the beginning of this chapter I stated that given a pointer to an object,
by zeroing the bits of the pointer that represent the block size, the result
points to the beginning of the block.</p>
<p>We'll make use of that now.</p>
<p>During the mark phase of garbage collection, we will need to know which line
or lines to mark, in addition to marking the object itself. We will make a
copy of the <code>BlockMeta</code> instance pointer in the 0th word of the memory block
so that given any object pointer, we can obtain the <code>BlockMeta</code> instance.</p>
<p>In the next chapter we'll handle multiple <code>BumpBlock</code>s so that we can keep
allocating objects after one block is full.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note that objects can be written from the end of the block down to the beginning
too, decrementing the bump pointer. This is usually <a href="https://fitzgeraldnick.com/2019/11/01/always-bump-downwards.html">slightly simpler and more
efficient to implement</a>.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="part-stickyimmix.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter-managing-blocks.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="part-stickyimmix.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter-managing-blocks.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
