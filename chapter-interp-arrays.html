<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Arrays - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html" class="active"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.8.</strong> TODO - Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.9.</strong> TODO - Compiler: Design</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.10.</strong> TODO - Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.11.</strong> TODO - Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.</strong> Advanced garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.1.</strong> TODO - ?</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.</strong> Full Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.1.</strong> TODO - ?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>Before we get to the basics of compilation, we need another data structure:
the humble array. The first use for arrays will be to store the bytecode
sequences that the compiler generates.</p>
<p>Rust already provides <code>Vec</code> but as we're implementing everything in terms of our
memory management abstraction, we cannot directly use <code>Vec</code>. Rust does not
(yet) expose the ability to specify a custom allocator type as part of <code>Vec</code>,
nor are we interested in replacing the global allocator.</p>
<p>Our only option is to write our own version of <code>Vec</code>! Fortunately we can
learn a lot from <code>Vec</code> itself and it's underlying implementation. Jump over to
the <a href="https://doc.rust-lang.org/nomicon/vec.html">Rustonomicon</a> for a primer on the internals of <code>Vec</code>.</p>
<p>The first thing we'll learn is to split the implementation into a <code>RawArray&lt;T&gt;</code>
type and an <code>Array&lt;T&gt;</code> type. <code>RawArray&lt;T&gt;</code> will provide an unsafe abstraction
while <code>Array&lt;T&gt;</code> will make a safe layer over it.</p>
<h2><a class="header" href="#rawarray" id="rawarray">RawArray</a></h2>
<p>If you've just come back from <em>Implementing Vec</em> in the Nomicon, you'll
recognize what we're doing below with <code>RawArray&lt;T&gt;</code>:</p>
<pre><code class="language-rust ignore">pub struct RawArray&lt;T: Sized&gt; {
    /// Count of T-sized objects that can fit in the array
    capacity: ArraySize,
    ptr: Option&lt;NonNull&lt;T&gt;&gt;,
}
</code></pre>
<p>Instead of <code>Unique&lt;T&gt;</code> for the pointer, we're using <code>Option&lt;NonNull&lt;T&gt;&gt;</code>.
One simple reason is that <code>Unique&lt;T&gt;</code> is likely to be permanently unstable and
only available internally to <code>std</code> collections. The other is that we can
avoid allocating the backing store if no capacity is requested yet, setting
the value of <code>ptr</code> to <code>None</code>.</p>
<p>For when we <em>do</em> know the desired capacity, there is
<code>RawArray&lt;T&gt;::with_capacity()</code>. This method, because it allocates, requires
access to the <code>MutatorView</code> instance. If you'll recall from the chapter on
the allocation API, the API provides an array allocation method with
signature:</p>
<pre><code class="language-rust ignore">AllocRaw::alloc_array(&amp;self, size_bytes: ArraySize) -&gt; Result&lt;RawPtr&lt;u8&gt;, AllocError&gt;;
</code></pre>
<p>This method is wrapped on the interpreter side by <code>Heap</code> and <code>MutatorView</code> and
in both cases the return value remains, simply, <code>RawPtr&lt;u8&gt;</code> in the success
case. It's up to <code>RawArray&lt;T&gt;</code> to receive the <code>RawPtr&lt;u8&gt;</code> value and maintain
it safely. Here's <code>with_capcity()</code>, now:</p>
<pre><code class="language-rust ignore">    pub fn with_capacity&lt;'scope&gt;(
        mem: &amp;'scope MutatorView,
        capacity: u32,
    ) -&gt; Result&lt;RawArray&lt;T&gt;, RuntimeError&gt; {
        // convert to bytes, checking for possible overflow of ArraySize limit
        let capacity_bytes = capacity
            .checked_mul(size_of::&lt;T&gt;() as ArraySize)
            .ok_or(RuntimeError::new(ErrorKind::BadAllocationRequest))?;

        Ok(RawArray {
            capacity: capacity,
            ptr: NonNull::new(mem.alloc_array(capacity_bytes)?.as_ptr() as *mut T),
        })
    }
</code></pre>
<h3><a class="header" href="#resizing" id="resizing">Resizing</a></h3>
<p>If a <code>RawArray&lt;T&gt;</code>'s content will exceed it's capacity, there is
<code>RawArray&lt;T&gt;::resize()</code>. It allocates a new backing array using the
<code>MutatorView</code> method <code>alloc_array()</code> and copies the content of the old
over to the new, finally swapping in the new backing array for the old.</p>
<p>The code for this is straightforward but a little longer, go check it out
in <code>interpreter/src/rawarray.rs</code>.</p>
<h3><a class="header" href="#accessing" id="accessing">Accessing</a></h3>
<p>Since <code>RawArray&lt;T&gt;</code> will be wrapped by <code>Array&lt;T&gt;</code>, we need a couple more
methods to access the raw memory:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized&gt; RawArray&lt;T&gt; {
    pub fn capacity(&amp;self) -&gt; ArraySize {
        self.capacity
    }

    pub fn as_ptr(&amp;self) -&gt; Option&lt;*const T&gt; {
        match self.ptr {
            Some(ptr) =&gt; Some(ptr.as_ptr()),
            None =&gt; None,
        }
    }
}
</code></pre>
<p>And that's it! Now for the safe wrapper.</p>
<h2><a class="header" href="#array" id="array">Array</a></h2>
<p>The definition of the struct wrapping <code>RawArray&lt;T&gt;</code> is as follows:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Array&lt;T: Sized + Clone&gt; {
    length: Cell&lt;ArraySize&gt;,
    data: Cell&lt;RawArray&lt;T&gt;&gt;,
    borrow: Cell&lt;BorrowFlag&gt;,
}
</code></pre>
<p>Here we have three members:</p>
<ul>
<li><code>length</code> - the length of the array</li>
<li><code>data</code> - the <code>RawArray&lt;T&gt;</code> being wrapped</li>
<li><code>borrow</code> - a flag serving as a runtime borrow check, allowing <code>RefCell</code>
runtime semantics, since we're in a world of interior mutability patterns</li>
</ul>
<p>We have a method to create a new array - <code>Array::alloc()</code></p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; Array&lt;T&gt; {
    pub fn alloc&lt;'guard&gt;(
        mem: &amp;'guard MutatorView,
    ) -&gt; Result&lt;ScopedPtr&lt;'guard, Array&lt;T&gt;&gt;, RuntimeError&gt;
    where
        Array&lt;T&gt;: AllocObject&lt;TypeList&gt;,
    {
        mem.alloc(Array::new())
    }
}
</code></pre>
<p>In fact we'll extend this pattern of a method named &quot;alloc&quot; to any data
structure for convenience sake.</p>
<p>There are many more methods for <code>Array&lt;T&gt;</code> and it would be exhausting to be
exhaustive. Let's go over the core methods used to read and write elements
and then an example use case.</p>
<h3><a class="header" href="#reading-and-writing" id="reading-and-writing">Reading and writing</a></h3>
<p>First of all, we need a function that takes an array index and returns a
pointer to a memory location, if the index is within bounds:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; Array&lt;T&gt; {
    fn get_offset(&amp;self, index: ArraySize) -&gt; Result&lt;*mut T, RuntimeError&gt; {
        if index &gt;= self.length.get() {
            Err(RuntimeError::new(ErrorKind::BoundsError))
        } else {
            let ptr = self
                .data
                .get()
                .as_ptr()
                .ok_or(RuntimeError::new(ErrorKind::BoundsError))?;

            let dest_ptr = unsafe { ptr.offset(index as isize) as *mut T };

            Ok(dest_ptr)
        }
    }
}
</code></pre>
<p>There are two bounds checks here - firstly, the index should be within the
(likely non-zero) length values; secondly, the <code>RawArray&lt;T&gt;</code> instance
should have a backing array allocated. If either of these checks fail, the
result is an error. If these checks pass, we can be confident that there
is array backing memory and that we can return a valid pointer to somewhere
inside that memory block.</p>
<p>For reading a value in an array, we need two methods:</p>
<ol>
<li>one that handles move/copy semantics and returns a value</li>
<li>one that handles reference semantics and returns a reference to the original
value in it's location in the backing memory</li>
</ol>
<p>First, then:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; Array&lt;T&gt; {
    fn read&lt;'guard&gt;(
        &amp;self,
        _guard: &amp;'guard dyn MutatorScope,
        index: ArraySize,
    ) -&gt; Result&lt;T, RuntimeError&gt; {
        unsafe {
            let dest = self.get_offset(index)?;
            Ok(read(dest))
        }
    }
}
</code></pre>
<p>and secondly:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; Array&lt;T&gt; {
    pub fn read_ref&lt;'guard&gt;(
        &amp;self,
        _guard: &amp;'guard dyn MutatorScope,
        index: ArraySize,
    ) -&gt; Result&lt;&amp;T, RuntimeError&gt; {
        unsafe {
            let dest = self.get_offset(index)?;
            Ok(&amp;*dest as &amp;T)
        }
    }
}
</code></pre>
<p>Writing, or copying, an object to an array is implemented as simply as follows:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; Array&lt;T&gt; {
    pub fn read_ref&lt;'guard&gt;(
        &amp;self,
        _guard: &amp;'guard dyn MutatorScope,
        index: ArraySize,
    ) -&gt; Result&lt;&amp;T, RuntimeError&gt; {
        unsafe {
            let dest = self.get_offset(index)?;
            Ok(&amp;*dest as &amp;T)
        }
    }
}
</code></pre>
<p>These simple functions should only be used internally by <code>Array&lt;T&gt;</code> impl
methods. We have numerous methods that wrap the above in more appropriate
semantics for values of <code>T</code> in <code>Array&lt;T&gt;</code>.</p>
<h3><a class="header" href="#the-array-interfaces" id="the-array-interfaces">The Array interfaces</a></h3>
<p>To define the interfaces to the Array, and other collection types, we define a
number of traits. For example, a collection that behaves as a stack implements
<code>StackContainer</code>; a numerically indexable type implements <code>IndexedContainer</code>,
and so on. As we'll see, there is some nuance, though, when it comes to a
difference between collections of non-pointer types and collections of pointer
types.</p>
<p>For our example, we will describe the stack interfaces of <code>Array&lt;T&gt;</code>.</p>
<p>First, the general case trait, with methods for accessing values stored in the
array (non-pointer types):</p>
<pre><code class="language-rust ignore">pub trait StackContainer&lt;T: Sized + Clone&gt;: Container&lt;T&gt; {
    /// Push can trigger an underlying array resize, hence it requires the ability to allocate
    fn push&lt;'guard&gt;(&amp;self, mem: &amp;'guard MutatorView, item: T) -&gt; Result&lt;(), RuntimeError&gt;;

    /// Pop returns a bounds error if the container is empty, otherwise moves the last item of the
    /// array out to the caller.
    fn pop&lt;'guard&gt;(&amp;self, _guard: &amp;'guard dyn MutatorScope) -&gt; Result&lt;T, RuntimeError&gt;;

    /// Return the value at the top of the stack without removing it
    fn top&lt;'guard&gt;(&amp;self, _guard: &amp;'guard dyn MutatorScope) -&gt; Result&lt;T, RuntimeError&gt;;
}
</code></pre>
<p>These are unremarkable functions, by now we're familiar with the references to
<code>MutatorScope</code> and <code>MutatorView</code> in method parameter lists.</p>
<p>In any instance of <code>Array&lt;T&gt;</code>, <code>T</code> need only implement <code>Clone</code> and cannot be
dynamically sized. Thus <code>T</code> can be any primitive type or any straightforward
struct.</p>
<p>What if we want to store pointers to other objects? For example, if we want a
heterogenous array, such as Python's <code>List</code> type, what would we provide in
place of <code>T</code>? The answer is to use the <code>TaggedCellPtr</code> type. However,
an <code>Array&lt;TaggedCellPtr</code>, because we want to interface with pointers and
use the memory access abstractions provided, can be made a little more
ergonomic. For that reason, we have separate traits for containers of type
<code>Container&lt;TaggedCellPtr</code>. In the case of the stack interface this looks like:</p>
<pre><code class="language-rust ignore">pub trait StackAnyContainer: StackContainer&lt;TaggedCellPtr&gt; {
    /// Push can trigger an underlying array resize, hence it requires the ability to allocate
    fn push&lt;'guard&gt;(
        &amp;self,
        mem: &amp;'guard MutatorView,
        item: TaggedScopedPtr&lt;'guard&gt;,
    ) -&gt; Result&lt;(), RuntimeError&gt;;

    /// Pop returns a bounds error if the container is empty, otherwise moves the last item of the
    /// array out to the caller.
    fn pop&lt;'guard&gt;(
        &amp;self,
        _guard: &amp;'guard dyn MutatorScope,
    ) -&gt; Result&lt;TaggedScopedPtr&lt;'guard&gt;, RuntimeError&gt;;

    /// Return the value at the top of the stack without removing it
    fn top&lt;'guard&gt;(
        &amp;self,
        _guard: &amp;'guard dyn MutatorScope,
    ) -&gt; Result&lt;TaggedScopedPtr&lt;'guard&gt;, RuntimeError&gt;;
}
</code></pre>
<p>As you can see, these methods, while for <code>T = TaggedCellPtr</code>, provide an
interface based on passing and returning <code>TaggedScopedPtr</code>.</p>
<p>Let's look at the implementation of one of these methods - <code>push()</code>  - for
both <code>StackContainer</code> and <code>StackAnyContainer</code>.</p>
<p>Here's the code for <code>StackContainer::push()</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: Sized + Clone&gt; StackContainer&lt;T&gt; for Array&lt;T&gt; {
    fn push&lt;'guard&gt;(&amp;self, mem: &amp;'guard MutatorView, item: T) -&gt; Result&lt;(), RuntimeError&gt; {
        if self.borrow.get() != INTERIOR_ONLY {
            return Err(RuntimeError::new(ErrorKind::MutableBorrowError));
        }

        let length = self.length.get();
        let mut array = self.data.get(); // Takes a copy

        let capacity = array.capacity();

        if length == capacity {
            if capacity == 0 {
                array.resize(mem, DEFAULT_ARRAY_SIZE)?;
            } else {
                array.resize(mem, default_array_growth(capacity)?)?;
            }
            // Replace the struct's copy with the resized RawArray object
            self.data.set(array);
        }

        self.length.set(length + 1);
        self.write(mem, length, item)?;
        Ok(())
    }
}
</code></pre>
<p>In summary, the order of operations is:</p>
<ol>
<li>Check that a runtime borrow isn't in progress. If it is, return an error.</li>
<li>Since we must implement interior mutability, the member <code>data</code> of the
<code>Array&lt;T&gt;</code> struct is a <code>Cell</code>. We have to <code>get()</code> the content in order
to use it.</li>
<li>We then ask whether the array backing store needs to be grown. If so,
we resize the <code>RawArray&lt;T&gt;</code> and, since it's kept in a <code>Cell</code> on <code>Array&lt;T&gt;</code>,
we have to <code>set()</code> value back into <code>data</code> to save the change.</li>
<li>Now we have an <code>RawArray&lt;T&gt;</code> that has enough capacity, the length is
incremented and the object to be pushed is written to the next memory
location using the internal <code>Array&lt;T&gt;::write()</code> method detailed earlier.</li>
</ol>
<p>Fortunately we can implement <code>StackAnyContainer::push()</code> in terms of
<code>StackContainer::push()</code>:</p>
<pre><code class="language-rust ignore">impl StackAnyContainer for Array&lt;TaggedCellPtr&gt; {
    fn push&lt;'guard&gt;(
        &amp;self,
        mem: &amp;'guard MutatorView,
        item: TaggedScopedPtr&lt;'guard&gt;,
    ) -&gt; Result&lt;(), RuntimeError&gt; {
        Ok(StackContainer::&lt;TaggedCellPtr&gt;::push(
            self,
            mem,
            TaggedCellPtr::new_with(item),
        )?)
    }
}
</code></pre>
<h3><a class="header" href="#one-last-thing" id="one-last-thing">One last thing</a></h3>
<p>To more easily differentiate arrays of type <code>Array&lt;T&gt;</code> from arrays of type
<code>Array&lt;TaggedCellPtr&gt;</code>, we make a type alias <code>List</code> where:</p>
<pre><code class="language-rust ignore">pub type List = Array&lt;TaggedCellPtr&gt;;
</code></pre>
<h2><a class="header" href="#in-conclusion" id="in-conclusion">In conclusion</a></h2>
<p>We referenced how <code>Vec</code> is implemented internally and followed the same pattern
of defining a <code>RawArray&lt;T&gt;</code> unsafe layer with a safe <code>Array&lt;T&gt;</code> wrapper. Then
we looked into the stack interface for <code>Array&lt;T&gt;</code> and the implementation of
<code>push()</code>.</p>
<p>There is more to arrays, of course - indexed access the most obvious, and also
a few convenience methods. See the source code in <code>interpreter/src/array.rs</code>
for the full detail.</p>
<p>In the next chapter we'll put <code>Array&lt;T&gt;</code> to use in a <code>Bytecode</code> type!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter-interp-parsing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter-interp-bytecode.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter-interp-parsing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter-interp-bytecode.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
