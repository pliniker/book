<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Virtual Machine: Implementation - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-design.html"><strong aria-hidden="true">4.8.</strong> Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-design.html"><strong aria-hidden="true">4.9.</strong> Compiler: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-impl.html" class="active"><strong aria-hidden="true">4.10.</strong> Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.11.</strong> TODO - Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#virtual-machine-implementation" id="virtual-machine-implementation">Virtual Machine: Implementation</a></h1>
<p>In this chapter we'll dive into some of the more interesting and important
implementation details of our virtual machine.</p>
<p>To begin with, we'll lay out a struct for a single thread of execution. This
struct should contain everything needed to execute the output of the compiler.</p>
<pre><code class="language-rust ignore">pub struct Thread {
    /// An array of CallFrames
    frames: CellPtr&lt;CallFrameList&gt;,
    /// An array of pointers any object type
    stack: CellPtr&lt;List&gt;,
    /// The current stack base pointer
    stack_base: Cell&lt;ArraySize&gt;,
    /// A dict that should only contain Number keys and Upvalue values. This is a mapping of
    /// absolute stack indeces to Upvalue objects where stack values are closed over.
    upvalues: CellPtr&lt;Dict&gt;,
    /// A dict that should only contain Symbol keys but any type as values
    globals: CellPtr&lt;Dict&gt;,
    /// The current instruction location
    instr: CellPtr&lt;InstructionStream&gt;,
}
</code></pre>
<p>Here we see every data structure needed to represent:</p>
<ul>
<li>function call frames</li>
<li>stack values</li>
<li>closed-over stack values (Upvalues)</li>
<li>global values</li>
<li>bytecode to execute</li>
</ul>
<p>The VM's primary operation is to iterate through instructions, executing each
in sequence. The outermost control struture is, therefore, a loop containing
a <code>match</code> expression.</p>
<p>Here is a code extract of the opening lines of this match operation. The
function shown is a member of the <code>Thread</code> struct. It evaluates the next
instruction and is called in a loop by an outer function. We'll look at several
extracts from this function in this chapter.</p>
<pre><code class="language-rust ignore">    /// Execute the next instruction in the current instruction stream
    fn eval_next_instr&lt;'guard&gt;(
        &amp;self,
        mem: &amp;'guard MutatorView,
    ) -&gt; Result&lt;EvalStatus&lt;'guard&gt;, RuntimeError&gt; {
        // TODO not all these locals are required in every opcode - optimize and get them only
        // where needed
        let frames = self.frames.get(mem);
        let stack = self.stack.get(mem);
        let globals = self.globals.get(mem);
        let instr = self.instr.get(mem);

        // Establish a 256-register window into the stack from the stack base
        stack.access_slice(mem, |full_stack| {
            let stack_base = self.stack_base.get() as usize;
            let window = &amp;mut full_stack[stack_base..stack_base + 256];

            // Fetch the next instruction and identify it
            let opcode = instr.get_next_opcode(mem)?;

            match opcode {
                // Do nothing.
                Opcode::NoOp =&gt; return Ok(EvalStatus::Pending),

                ...
</code></pre>
<p>The function obtains a slice view of the register stack, then narrows that down
to a 256 register window for the current function.</p>
<p>Then it fetches the next opcode and using <code>match</code>, decodes it.</p>
<p>Let's take a closer look at the stack.</p>
<h2><a class="header" href="#the-stack" id="the-stack">The stack</a></h2>
<p>While some runtimes and compilers, particularly low-level languages, have a
single stack that represents both function call information and local variables,
our high-level runtime splits the stack into:</p>
<ol>
<li>a stack of <code>CallFrame</code> objects containing function call and return
information</li>
<li>and a register stack for local variables.</li>
</ol>
<p>Let's look at each in turn.</p>
<h3><a class="header" href="#the-register-stack" id="the-register-stack">The register stack</a></h3>
<p>In our <code>Thread</code> struct, the register stack is represented by the two members:</p>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    stack: CellPtr&lt;List&gt;,
    stack_base: Cell&lt;ArraySize&gt;,
    ...
}
</code></pre>
<p>Remember that the <code>List</code> type is defined as <code>Array&lt;TaggedCellPtr&gt;</code> and is
therefore an array of tagged pointers. Thus, the register stack is a homogenous
array of word sized values that are pointers to objects on the heap or values
that can be inlined in the tagged pointer word.</p>
<p>We also have a <code>stack_base</code> variable to quickly retrieve the offset into <code>stack</code>
that indicates the beginning of the window of 256 registers that the current
function has for it's local variables.</p>
<h3><a class="header" href="#the-call-frame-stack" id="the-call-frame-stack">The call frame stack</a></h3>
<p>In our <code>Thread</code> struct, the call frame stack is represented by the members:</p>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    frames: CellPtr&lt;CallFrameList&gt;,
    instr: CellPtr&lt;InstructionStream&gt;,
    ...
}
</code></pre>
<p>A <code>CallFrame</code> and an array of them are defined as:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct CallFrame {
    /// Pointer to the Function being executed
    function: CellPtr&lt;Function&gt;,
    /// Return IP when returning from a nested function call
    ip: Cell&lt;ArraySize&gt;,
    /// Stack base - index into the register stack where register window for this function begins
    base: ArraySize,
}

pub type CallFrameList = Array&lt;CallFrame&gt;;
</code></pre>
<p>A <code>CallFrame</code> contains all the information needed to resume a function when
a nested function call returns:</p>
<ul>
<li>a <code>Function</code> object, which references the <code>Bytecode</code> comprising the
function</li>
<li>the return instruction pointer</li>
<li>the stack base index for the function's stack register window</li>
</ul>
<p>On every function call, a <code>CallFrame</code> instance is pushed on to the <code>Thread</code>'s
<code>frames</code> stack and on every return from a function, the top <code>CallFrame</code> is
popped off the stack.</p>
<p>Additionally, we keep a pointer to the current executing function (the function
represented by the top <code>CallFrame</code>) with the member <code>instr: CellPtr&lt;InstructionStream&gt;</code>.</p>
<p>For a review of the definition of <code>InstructionStream</code> see the
<a href="./chapter-interp-bytecode.html">bytecode</a> chapter where we defined it as
a pair of values - a <code>ByteCode</code> reference and a pointer to the next <code>Opcode</code>
to fetch.</p>
<p>The VM keeps the <code>InstructionStream</code> object pointing at the same <code>ByteCode</code>
object as is pointed at by the <code>Function</code> in the <code>CallFrame</code> at the top of
the call frame stack. Thus, when a call frame is popped off the stack, the
<code>InstructionStream</code> is updated with the <code>ByteCode</code> and instruction pointer
from the <code>CallFrame</code> at the new stack top; and similarly when a function
is called <em>into</em> and a new <code>CallFrame</code> is pushed on to the stack.</p>
<h2><a class="header" href="#functions-and-function-calls" id="functions-and-function-calls">Functions and function calls</a></h2>
<h3><a class="header" href="#function-objects" id="function-objects">Function objects</a></h3>
<p>Since we've mentioned <code>Function</code> objects above, let's now have a look at the
definition.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Function {
    /// name could be a Symbol, or nil if it is an anonymous fn
    name: TaggedCellPtr,
    /// Number of arguments required to activate the function
    arity: u8,
    /// Instructions comprising the function code
    code: CellPtr&lt;ByteCode&gt;,
    /// Param names are stored for introspection of a function signature
    param_names: CellPtr&lt;List&gt;,
    /// List of (CallFrame-index: u8 | Window-index: u8) relative offsets from this function's
    /// declaration where nonlocal variables will be found. Needed when creating a closure. May be
    /// nil
    nonlocal_refs: TaggedCellPtr,
}
</code></pre>
<p>Instances of <code>Function</code> are produced by the compiler, one for each function
definition that is compiled.</p>
<p>A <code>Function</code> object is a simple collection of values, some of which may be
<code>nil</code>. Any member represented by a <code>TaggedCellPtr</code> may, of course, contain
a <code>nil</code> value.</p>
<p>Thus the function may be anonymous, represented by a <code>nil</code> name value.</p>
<p>While the function name is optional, the parameter names are always included.
Though they do not need to be known in order to execute the function, they are
useful for representing the function in string form if the programmer needs to
introspect a function object.</p>
<p>Members that are <em>required</em> to execute the function are the arity, the
<code>ByteCode</code> and any nonlocal references.</p>
<p>Nonlocal references are an optional list of <code>(relative_stack_frame, register)</code>
tuples, provided by the compiler, that are needed to locate nonlocal variables
on the register stack. These are, of course, a key component of implementing
closures.</p>
<p>We'll talk about closures shortly, but before we do, we'll extend <code>Function</code>s
with partial application of arguments.</p>
<h3><a class="header" href="#partial-functions" id="partial-functions">Partial functions</a></h3>
<p>A partial function application takes a subset of the arguments required to
make a function call. These arguments must be stored for later.</p>
<p>Thus, a <code>Partial</code> object references the <code>Function</code> to be called and a list
of arguments to give it when the call is finally executed.</p>
<p>Below is the definition of <code>Partial</code>. Note that it also contains a possible
closure environment. We'll discuss that in the next section.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Partial {
    /// Remaining number of arguments required to activate the function
    arity: u8,
    /// Number of arguments already applied
    used: u8,
    /// List of argument values already applied
    args: CellPtr&lt;List&gt;,
    /// Closure environment - must be either nil or a List of Upvalues
    env: TaggedCellPtr,
    /// Function that will be activated when all arguments are applied
    func: CellPtr&lt;Function&gt;,
}
</code></pre>
<p>The <code>arity</code> and <code>used</code> members indicate how many arguments are expected and how
many have been given. These are provided directly in this struct rather than
requiring dereferencing the <code>arity</code> on the <code>Function</code> object and the length of
the <code>args</code> list. This is for convenience and performance.</p>
<p>Each time more arguments are added to a <code>Partial</code>, a new <code>Partial</code> instance must
be allocated and the existing arguments copied over. A <code>Partial</code> object, once
created, is immutable.</p>
<h3><a class="header" href="#closures" id="closures">Closures</a></h3>
<p>Closures and partial applications have, at an abstract level, something in
common: they both reference values that the function will need when it is
finally called.</p>
<p>It's also possible, of course, to have a partially applied closure.</p>
<p>We can extend the <code>Partial</code> definition with a closure environment so that we can
use the same object type everywhere to represent a function pointer, applied
arguments and closure environment as needed.</p>
<h4><a class="header" href="#compiling-a-closure" id="compiling-a-closure">Compiling a closure</a></h4>
<p>The compiler, because it keeps track of variable names and scopes, knows when a
<code>Function</code> references nonlocal variables. After such a function is defined, the
compiler emits a <code>MakeClosure</code> instruction.</p>
<h4><a class="header" href="#referencing-the-stack-with-upvalues" id="referencing-the-stack-with-upvalues">Referencing the stack with upvalues</a></h4>
<p>The VM, when it executes <code>MakeClosure</code>, creates a new <code>Partial</code> object.  It
then iterates over the list of nonlocal references and allocates an <code>Upvalue</code>
object for each, which are added to the <code>env</code> member on the <code>Partial</code> object.</p>
<p>The below code extract is from the function <code>Thread::eval_next_instr()</code> in
the <code>MakeClosure</code> instruction decode and execution block.</p>
<p>The two operands of the <code>MakeClosure</code> operation - <code>dest</code> and <code>function</code> - are
registers. <code>function</code> points at the <code>Function</code> to be given an environment and
made into a closure <code>Partial</code> instance; the pointer to this instance will be
written to the <code>dest</code> register.</p>
<pre><code class="language-rust ignore">                // This operation should be generated by the compiler after a function definition
                // inside another function but only if the nested function refers to nonlocal
                // variables.
                // The result of this operation is a Partial with a closure environment
                Opcode::MakeClosure { dest, function } =&gt; {
                    // 1. iter over function nonlocals
                    //   - calculate absolute stack offset for each
                    //   - find existing or create new Upvalue for each
                    //   - copy Upvalue ref to Partial applied args on the stack
                    // 2. create new Partial
                    // 3. set dest to Partial
                    let function_ptr = window[function as usize].get(mem);
                    if let Value::Function(f) = *function_ptr {
                        let nonlocals = f.nonlocals(mem);
                        let env = List::alloc_with_capacity(mem, nonlocals.length())?;

                        // Iter over function nonlocals, calculating absolute stack offset for each
                        nonlocals.access_slice(mem, |nonlocals| -&gt; Result&lt;(), RuntimeError&gt; {
                            for compound in nonlocals {
                                let frame_offset = (*compound &gt;&gt; 8) as ArraySize;
                                let window_offset = (*compound &amp; 0xff) as ArraySize;

                                // look back frame_offset frames and add the register number
                                let frame = frames.get(mem, frames.length() - frame_offset)?;
                                let location = frame.base + window_offset;

                                let (_, upvalue) = self.upvalue_lookup_or_alloc(mem, location)?;
                                StackAnyContainer::push(&amp;*env, mem, upvalue.as_tagged(mem))?;
                            }

                            Ok(())
                        })?;

                        // Instantiate a Partial function application from the closure environment
                        // and set the destination register
                        let partial = Partial::alloc(mem, f, Some(env), &amp;[])?;
                        window[dest as usize].set(partial.as_tagged(mem));
                    } else {
                        return Err(err_eval(&quot;Cannot make a closure from a non-Function type&quot;));
                    }
                }
</code></pre>
<p>The <code>Upvalue</code> struct itself is defined as:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Upvalue {
    // Upvalue location can't be a pointer because it would be a pointer into the dynamically
    // alloocated stack List - the pointer would be invalidated if the stack gets reallocated.
    value: TaggedCellPtr,
    closed: Cell&lt;bool&gt;,
    location: ArraySize,
}
</code></pre>
<p>An <code>Upvalue</code> is an object that references an absolute register stack location
(that is the <code>location</code> member.)</p>
<p>The initial value of <code>closed</code> is <code>false</code>. In this state, the location on the
stack that contains the variable <em>must</em> be a valid location. That is, the stack
can not have been unwound yet. If the closure is called, <code>Upvalue</code>s in this
state are simply an indirection between the function and the variable on the
register stack.</p>
<p>The compiler is able to keep track of variables and whether they are closed
over. It emits bytecode instructions to close <code>Upvalue</code> objects when variables
on the stack go out of scope.</p>
<p>This instruction, <code>CloseUpvalues</code>, copies the variable from the register stack
to the <code>value</code> member of the <code>Upvalue</code> object and sets <code>closed</code> to <code>true</code>.</p>
<p>From then on, when the closure reads or writes to this variable, the value on
the <code>Upvalue</code> object is modified rather than the location on the register stack.</p>
<h2><a class="header" href="#global-values" id="global-values">Global values</a></h2>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    globals: CellPtr&lt;Dict&gt;,
    ...
}
</code></pre>
<p>The outermost scope of a program's values and functions are the global values.
We can manage these with an instance of a <code>Dict</code>. While a <code>Dict</code> can use any
hashable value as a key, internally the VM will only allow <code>Symbol</code>s to be
keys. That is, globals must be named objects.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter-interp-compiler-design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="404.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter-interp-compiler-design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="404.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
