<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Virtual Machine: Implementation - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-design.html"><strong aria-hidden="true">4.8.</strong> Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-design.html"><strong aria-hidden="true">4.9.</strong> Compiler: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-impl.html" class="active"><strong aria-hidden="true">4.10.</strong> Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.11.</strong> TODO - Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.</strong> Advanced garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">6.1.</strong> TODO - ?</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.</strong> Full Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">7.1.</strong> TODO - ?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#virtual-machine-implementation" id="virtual-machine-implementation">Virtual Machine: Implementation</a></h1>
<p>This chapter will explain some of the more important implementation details
of our virtual machine.</p>
<p>We'll begin by laying out a struct for a single thread of execution:</p>
<pre><code class="language-rust ignore">pub struct Thread {
    /// An array of CallFrames
    frames: CellPtr&lt;CallFrameList&gt;,
    /// An array of pointers any object type
    stack: CellPtr&lt;List&gt;,
    /// The current stack base pointer
    stack_base: Cell&lt;ArraySize&gt;,
    /// A dict that should only contain Number keys and Upvalue values. This is a mapping of
    /// absolute stack indeces to Upvalue objects where stack values are closed over.
    upvalues: CellPtr&lt;Dict&gt;,
    /// A dict that should only contain Symbol keys but any type as values
    globals: CellPtr&lt;Dict&gt;,
    /// The current instruction location
    instr: CellPtr&lt;InstructionStream&gt;,
}
</code></pre>
<p>This struct contains every data structure needed to represent global values,
stack values, closed-over stack values, function call frames and instructions
to execute.</p>
<p>Let's look at each one of these.</p>
<h2><a class="header" href="#the-stack" id="the-stack">The stack</a></h2>
<p>The stack is separated into a stack of <code>CallFrame</code> instances and a register
stack.</p>
<h3><a class="header" href="#the-register-stack" id="the-register-stack">The register stack</a></h3>
<p>In our <code>Thread</code> struct, the register stack is represented by the two members:</p>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    stack: CellPtr&lt;List&gt;,
    stack_base: Cell&lt;ArraySize&gt;,
    ...
}
</code></pre>
<p>Remember that the <code>List</code> type is defined as <code>Array&lt;TaggedCellPtr&gt;</code> and is
therefore an array of tagged pointers. Thus, the register stack is a homogenous
array of word sized values that are pointers to objects on the heap or values
that can be inlined in the tagged pointer word.</p>
<h3><a class="header" href="#the-call-frame-stack" id="the-call-frame-stack">The call frame stack</a></h3>
<p>In our <code>Thread</code> struct, the call frame stack is represented by the member:</p>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    frames: CellPtr&lt;CallFrameList&gt;,
    instr: CellPtr&lt;InstructionStream&gt;,
    ...
}
</code></pre>
<p>Where <code>CallFrameList</code> is defined as</p>
<pre><code class="language-rust ignore">pub type CallFrameList = Array&lt;CallFrame&gt;;
</code></pre>
<p>and a <code>CallFrame</code> struct is defined as:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct CallFrame {
    /// Pointer to the Function being executed
    function: CellPtr&lt;Function&gt;,
    /// Return IP when returning from a nested function call
    ip: Cell&lt;ArraySize&gt;,
    /// Stack base - index into the register stack where register window for this function begins
    base: ArraySize,
}
</code></pre>
<p>A <code>CallFrame</code> contains all the information needed to resume a function when
a nested function call returns:</p>
<ul>
<li>the <code>Function</code> object, which references the <code>Bytecode</code> comprising the
function</li>
<li>the return instruction pointer</li>
<li>the stack base index for the function's stack register window</li>
</ul>
<p>On every function call, a <code>CallFrame</code> instance is pushed on to the <code>Thread</code>'s
frames list.</p>
<p>Directly related to the call frame stack is the current instruction pointer.
This is the <code>Thread</code> member <code>instr: CellPtr&lt;InstructionStream&gt;</code>,</p>
<p>For a review of the definition of <code>InstructionStream</code> see the
<a href="./chapter-interp-bytecode.html">bytecode</a> chapter where we defined it as
a pair of values - a <code>ByteCode</code> reference and a pointer to the next <code>Opcode</code>
to fetch.</p>
<p>The VM keeps the <code>InstructionStream</code> object pointing at the same <code>ByteCode</code>
object as is pointed at by the <code>Function</code> in the <code>CallFrame</code> at the top of
the call frame stack. Thus, when a call frame is popped off the stack, the
<code>InstructionStream</code> is updated with the <code>ByteCode</code> and instruction pointer
from the <code>CallFrame</code> at the new stack top; and similarly when a function
is called <em>into</em> and a new <code>CallFrame</code> is pushed on to the stack.</p>
<h2><a class="header" href="#function-objects" id="function-objects">Function objects</a></h2>
<p>Since we've mentioned <code>Function</code> objects above, let's now have a look at the
definition.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Function {
    /// name could be a Symbol, or nil if it is an anonymous fn
    name: TaggedCellPtr,
    /// Number of arguments required to activate the function
    arity: u8,
    /// Instructions comprising the function code
    code: CellPtr&lt;ByteCode&gt;,
    /// Param names are stored for introspection of a function signature
    param_names: CellPtr&lt;List&gt;,
    /// List of (CallFrame-index: u8 | Window-index: u8) relative offsets from this function's
    /// declaration where nonlocal variables will be found. Needed when creating a closure. May be
    /// nil
    nonlocal_refs: TaggedCellPtr,
}
</code></pre>
<p>Instances of <code>Function</code> are produced by the compiler, one for each function
definition that is compiled.</p>
<p>A <code>Function</code> object is a simple collection of values, some of which may be
<code>nil</code>. Any member represented by a <code>TaggedCellPtr</code> may, of course, contain
a <code>nil</code> value.</p>
<p>Thus the function may be anonymous, represented by a <code>nil</code> name member value.
While the function name is optional, the parameter names are always included.
While they do not need to be known in order to execute the function, they are
useful for representing the function if the programmer needs to introspect a
function object.</p>
<p>Members that are required to execute the function are the arity, the <code>ByteCode</code>
and any nonlocal references.</p>
<p>Nonlocal references are an optional list of <code>(relative_stack_frame, register)</code>
values provided by the compiler that are needed to locate nonlocal variables on
the register stack. These are, of course, a key component of implementing
closures. We'll talk about closures shortly, but before we do, we'll extend
<code>Function</code>s with partial application of arguments.</p>
<h2><a class="header" href="#partial-functions" id="partial-functions">Partial functions</a></h2>
<p>A partial function application takes a subset of the arguments required to
make a function call. These arguments must be stored for later.</p>
<p>Thus, a <code>Partial</code> object references the <code>Function</code> to be called and a list
of arguments to give it when the call happens. Below is the definition
of <code>Partial</code>. Note that it also contains a possible closure environment.
We'll discuss that in the next section.</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Partial {
    /// Remaining number of arguments required to activate the function
    arity: u8,
    /// Number of arguments already applied
    used: u8,
    /// List of argument values already applied
    args: CellPtr&lt;List&gt;,
    /// Closure environment - must be either nil or a List of Upvalues
    env: TaggedCellPtr,
    /// Function that will be activated when all arguments are applied
    func: CellPtr&lt;Function&gt;,
}
</code></pre>
<p>The <code>arity</code> and <code>used</code> members indicate how many arguments are expected and how
many have been given. These are provided directly in this struct rather than
requiring dereferencing the <code>arity</code> on the <code>Function</code> object and the length of
the <code>args</code> list. This is for convenience and performance.</p>
<p>Each time more arguments are added to a <code>Partial</code>, a new <code>Partial</code> instance must
be allocated and the existing arguments copied over. Essentially, a <code>Partial</code>
object, once created, is immutable.</p>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Closures and partial applications have, at an abstract level, something in
common: they both reference values that the function will need when it is
finally called and need to carry these references around with them.</p>
<p>It's possible, of course, to have a partially applied closure. We can extend the
<code>Partial</code> definition with a closure environment so that we can use the same
object type everywhere to represent a function pointer, applied arguments and
closure environment as needed.</p>
<h3><a class="header" href="#compiling-a-closure" id="compiling-a-closure">Compiling a closure</a></h3>
<p>The compiler, because it keeps track of variable names and scopes, knows when a
<code>Function</code> references nonlocal variables. When such a function is going to be
referenced to be called next or at some later time, the compiler emits a
<code>MakeClosure</code> instruction.</p>
<h3><a class="header" href="#referencing-the-stack-with-upvalues" id="referencing-the-stack-with-upvalues">Referencing the stack with upvalues</a></h3>
<p>The VM, when it executes <code>MakeClosure</code>, creates a new <code>Partial</code> object.  It
then iterates over the list of nonlocal references and allocates an <code>Upvalue</code>
object for each, which are added to the <code>env</code> member on the <code>Partial</code> object.
The <code>Upvalue</code> struct is defined as:</p>
<pre><code class="language-rust ignore">#[derive(Clone)]
pub struct Upvalue {
    // Upvalue location can't be a pointer because it would be a pointer into the dynamically
    // alloocated stack List - the pointer would be invalidated if the stack gets reallocated.
    value: TaggedCellPtr,
    closed: Cell&lt;bool&gt;,
    location: ArraySize,
}
</code></pre>
<p>An <code>Upvalue</code> is an object that references a register stack location (that is
the <code>location</code> member.) The initial value of <code>closed</code> is <code>false</code>.  In this
state, the location on the stack that contains the variable <em>must</em> be a valid
location. That is, the stack can not have been unwound yet.  If the closure is
called, <code>Upvalue</code>s in this state are simply an indirection between the function
and the variable on the register stack.</p>
<p>The compiler is able to keep track of variables and whether they are closed
over. It emits bytecode instructions to close <code>Upvalue</code> objects when
closed-over variables go out of scope. This instruction, <code>CloseUpvalues</code>,
copies the variable from the register stack to the <code>value</code> member of the
<code>Upvalue</code> object and sets <code>closed</code> to <code>true</code>. From now on, when the closure
reads or writes to this variable, the value on the <code>Upvalue</code> object is modified
rather than the location on the register stack.</p>
<h2><a class="header" href="#global-values" id="global-values">Global values</a></h2>
<pre><code class="language-rust ignore">pub struct Thread {
    ...
    globals: CellPtr&lt;Dict&gt;,
    ...
}
</code></pre>
<p>The outermost scope of a program's values and functions are the global values.
We can manage these with an instance of a <code>Dict</code>. While a <code>Dict</code> can use any
hashable value as a key, internally the VM will only allow <code>Symbol</code>s to be
keys. That is, globals must be named objects.</p>
<h2><a class="header" href="#tying-it-all-together" id="tying-it-all-together">Tying it all together</a></h2>
<include VM code snippets here>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter-interp-compiler-design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="404.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter-interp-compiler-design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="404.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
