<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Compiler: Design - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating objects and dereferencing safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-ptrs.html"><strong aria-hidden="true">4.2.</strong> Tagged pointers and object headers</a></li><li class="chapter-item expanded "><a href="chapter-interp-symbols-and-pairs.html"><strong aria-hidden="true">4.3.</strong> Symbols and Pairs</a></li><li class="chapter-item expanded "><a href="chapter-interp-parsing.html"><strong aria-hidden="true">4.4.</strong> Parsing s-expressions</a></li><li class="chapter-item expanded "><a href="chapter-interp-arrays.html"><strong aria-hidden="true">4.5.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="chapter-interp-bytecode.html"><strong aria-hidden="true">4.6.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="chapter-interp-dicts.html"><strong aria-hidden="true">4.7.</strong> Dicts</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-design.html"><strong aria-hidden="true">4.8.</strong> Virtual Machine: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-compiler-design.html" class="active"><strong aria-hidden="true">4.9.</strong> Compiler: Design</a></li><li class="chapter-item expanded "><a href="chapter-interp-vm-impl.html"><strong aria-hidden="true">4.10.</strong> Virtual Machine: Implementation</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">4.11.</strong> TODO - Compiler: Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.</strong> Garbage collection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.1.</strong> TODO - Tracing</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.2.</strong> TODO - Sweeping</a></li><li class="chapter-item expanded "><a href="404.html"><strong aria-hidden="true">5.3.</strong> TODO - Recycling blocks</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#compiler-design" id="compiler-design">Compiler: Design</a></h1>
<p>Drawing from the <a href="./chapter-interp-vm-design.html">VM design</a>, the compiler must
support the following language constructs:</p>
<ul>
<li>function definitions</li>
<li>anonymous functions</li>
<li>function calls</li>
<li>lexical scoping</li>
<li>closures</li>
<li>local variables</li>
<li>global variables</li>
<li>expressions</li>
</ul>
<p>This is a minimally critical set of features that any further language
constructs can be built on while ensuring that our compiler remains easy to
understand for the purposes of this book.</p>
<p><a href="./chapter-interp-parsing.html">Our parser, recall</a>, reads in s-expression syntax
and produces a nested <code>Pair</code> and <code>Symbol</code> based abstract syntax tree. Adding
other types - integers, strings, arrays etc - is mostly a matter of expanding
the parser.  The compiler as described here, being for a dynamically typed
language, will support them without refactoring.</p>
<h2><a class="header" href="#evalapply" id="evalapply">Eval/apply</a></h2>
<p>Our compiler design is based on the <em>eval/apply</em> pattern.</p>
<p>In this pattern we recursively descend into the <code>Pair</code> AST, calling <em>eval</em> on
the root node of the expression to be compiled.</p>
<p><em>Eval</em> is, of course, short for &quot;evaluate&quot; - we want to evaluate the given
expression. In the case of a compiler, we don't want the result yet, rather
the sequence of instructions that will generate the result.</p>
<p>More concretely, <em>eval</em> looks at the node in the AST it is given and if it
resolves to fetching a value for a variable, it generates that instruction;
otherwise if it is a compound expression, the arguments are evaluated and then
the function and arguments are passed to <em>apply</em>, which generates appropriate
function call instructions.</p>
<h3><a class="header" href="#implementing-eval" id="implementing-eval">Implementing Eval</a></h3>
<p><em>Eval</em> looks at the given node and attempts to generate an instruction for it
that would resolve the node to a value - that is, evaluate it.</p>
<h4><a class="header" href="#symbols" id="symbols">Symbols</a></h4>
<p>If the node is a special symbol, such as <code>nil</code> or <code>true</code>, then it is treated as
a literal and an instruction is generated to load that literal symbol into the
next available register.</p>
<p>Otherwise if the node is any other symbol, it is assumed to be bound to a value
(it must be a variable) and an instruction is generated for fetching the value
into a register.</p>
<p>Variables come in three kinds: local, nonlocal or global.</p>
<p><strong>Local</strong>: the symbol has been declared earlier in the expression (either it is
a function parameter or it was declared using <code>let</code>) and the compiler already
has a record of it. The symbol is already associated with a local register
index and a simple register copy instruction is generated.</p>
<p><strong>Nonlocal</strong>: the symbol has been bound in a parent nesting function. Again,
the compiler already has a record of the declaration, which register is
associated with the symbol and which relative call frame will contain that
register. An upvalue lookup instruction is generated.</p>
<p><strong>Global</strong>: if the symbol isn't found as a local binding or a nonlocal binding,
it is assumed to be a global, and a late-binding global lookup instruction is
generated. In the event the programmer has misspelled a variable name, this is
possibly the instruction that will be generated and the programmer will see an
unknown-variable error at runtime.</p>
<h4><a class="header" href="#expressions-and-function-calls" id="expressions-and-function-calls">Expressions and function calls</a></h4>
<p>When <em>eval</em> is passed a <code>Pair</code>, this represents the beginning of an expression,
a function call. A composition of things.</p>
<p>In s-expression syntax, all expressions and function calls looks like
<code>(function_name arg1 arg2)</code>.  That is parsed into a <code>Pair</code> tree, which takes
the form:</p>
<pre><code>Pair(
  Symbol(function_name),
  Pair(
    Symbol(arg1),
    Pair(
      Symbol(arg2),
      nil
    )
  )
)
</code></pre>
<p>It is <em>apply</em>'s job to handle this case, so <em>eval</em> extracts the first and
second values from the outermost <code>Pair</code> and passes them into apply. In more
general terms, <em>eval</em> calls <em>apply</em> with the function name and the argument
list and leaves the rest up to <em>apply</em>.</p>
<h3><a class="header" href="#implementing-apply" id="implementing-apply">Implementing Apply</a></h3>
<p><em>Apply</em> takes a function name and a list of arguments. First it recurses into
<em>eval</em> for each argument expression, then  generates instructions to call the
function with the argument results.</p>
<h4><a class="header" href="#calling-functions" id="calling-functions">Calling functions</a></h4>
<p>Functions are either built into to the language and VM or are
library/user-defined functions composed of other functions.</p>
<p>In every case, the simplified pattern for function calls is:</p>
<ul>
<li>allocate a register to write the return value into</li>
<li><em>eval</em> each of the arguments in sequence, allocating their resulting values 
into consequent registers</li>
<li>compile the function call opcode, giving it the number of argument registers
it should expect</li>
</ul>
<p>Compiling a call to a builtin function might translate directly to a dedicated
bytecode operation. For example, querying whether a value is <code>nil</code> with builtin
function <code>nil?</code> compiles 1:1 to a bytecode operation that directly represents
that query.</p>
<p>Compiling a call to a user defined function is a more involved. In it's more
general form, supporting first class functions and closures, a function call
requires two additional pointers to be placed in registers. The complete
function call register allocation looks like this:</p>
<table><thead><tr><th>Register</th><th>Use</th></tr></thead><tbody>
<tr><td>0</td><td>reserved for return value</td></tr>
<tr><td>1</td><td>reserved for closure environment pointer</td></tr>
<tr><td>2</td><td>first argument</td></tr>
<tr><td>3</td><td>second argument</td></tr>
<tr><td>...</td><td></td></tr>
<tr><td>n</td><td>function pointer</td></tr>
</tbody></table>
<p>If a closure is called, the closure object itself contains a pointer to it's
environment and the function to call and those pointers can be copied over to
registers. Otherwise, the closure environment pointer will be a <code>nil</code> pointer.</p>
<p>The VM, when entering a new function, will represent the return value register
always as the zeroth register.</p>
<p>When the function call returns, all registers except the return value are
discarded.</p>
<h4><a class="header" href="#compiling-functions" id="compiling-functions">Compiling functions</a></h4>
<p>Let's look at a simple function definition:</p>
<pre><code>(def is_true (x) 
  (is? x true))
</code></pre>
<p>This function has a name <code>is_true</code>, takes one argument <code>x</code> and evaluates one
expression <code>(is? x true)</code>.</p>
<p>The same function may be written without a name:</p>
<pre><code>(lambda (x) (is? x true))
</code></pre>
<p>Compiling a function requires a few inputs:</p>
<ul>
<li>an optional reference to a parent nesting function</li>
<li>an optional function name</li>
<li>a list of argument names</li>
<li>a list of expressions that will compute the return value</li>
</ul>
<p>The desired output is a data structure that combines:</p>
<ul>
<li>the optional function name</li>
<li>the argument names</li>
<li>the compiled bytecode</li>
</ul>
<p>First, a scope structure is established. A scope is a lexical block in which
variables are bound and unbound. In the compiler, this structure is simply a
mapping of variable name to the register number that contains the value.</p>
<p>The first variables to be bound in the function's scope are the argument names.
The compiler, given the list of argument names to the function and the order in
which the arguments are given, associates each argument name with the register
number that will contain it's value. As we saw above, these are predictably and
reliably registers 2 and upward, one for each argument.</p>
<p>A scope may have a parent scope if the function is defined within another
function. This is how nonlocal variable references will be looked up. We will
go further into that when we discuss closures.</p>
<p>The second step is to <em>eval</em> each expression in the function, assigning the
result to register 0, the preallocated return value register. The result of
compiling each expression via <em>eval</em> is bytecode.</p>
<p>Thirdly and finally, a function object is instantiated, given it's name, the
argument names and the bytecode.</p>
<h4><a class="header" href="#compiling-closures" id="compiling-closures">Compiling closures</a></h4>
<p>During compilation of the expressions within a function, if any of those
expressions reference nonlocal variables (that is, variables not declared
within the scope of the function) then the function object needs additional
data to describe how to access those nonlocal variables at runtime.</p>
<p>In the below example, the anonymous inner function references the parameter
<code>n</code> to the outer function, <code>n</code>. When the inner function is returned, the value
of <code>n</code> must be carried with it even after the stack scope of the outer function
is popped and later overwritten with values for other functions.</p>
<pre><code>(def make_adder (n) 
  (lambda (x) (+ x n))
)
</code></pre>
<p><em>Eval</em>, when presented with a symbol to evaluate that has not been declared in
the function scope, searches outer scopes next. If a binding is found in an
outer scope, a nonlocal reference is added to the function's <em>local</em> scope
that points to the outer scope and a <code>GetUpvalue</code> instruction is compiled.</p>
<p>This nonlocal reference is a combination of two values: a count of stack
frames to skip over to find the outer scope variable and the register offset in
that stack frame.</p>
<p>Non-local references are added to the function object that is returned by the
function compiler. The VM will use these to identify the absolute location on
the stack where a nonlocal variable should be read from and create upvalue
objects at runtime when a variable is closed over.</p>
<h4><a class="header" href="#compiling-let" id="compiling-let">Compiling let</a></h4>
<p>Let is the declaration of variables and assigning values: the binding of 
values, or the results of expressions, to symbols. Secondly, it provides
space to evaluate expressions that incorporate those variables.</p>
<p>Here we bind the result of <code>(make_adder 3)</code> - a function - to the symbol
<code>add_3</code> and then call <code>add_3</code> with argument <code>4</code>.</p>
<pre><code>(let ((add_3 (make_adder 3)))
  (add_3 4))
</code></pre>
<p>The result of the entire <code>let</code> expression should be <code>7</code>.</p>
<p>Compiling <code>let</code> simply introduces additional scopes within a function scope.
That is, instead of a function containing a single scope for all it's
variables, scopes are nested. A stack of scopes is needed, with the parameters
occupying the outermost scope.</p>
<p>First a new scope is pushed on to the scope stack and each symbol being bound
is added to the new scope.</p>
<p>To generate code, a result register is reserved and a register for each binding
is reserved.</p>
<p>Finally, each expression is evaluated and the scope is popped, removing the
bindings from view.</p>
<h2><a class="header" href="#register-allocation" id="register-allocation">Register allocation</a></h2>
<p>A function call may make use of no more than 256 registers. Recall from earlier
that the 0th register is reserved for the function return value and subsequent
registers are reserved for the function arguments.</p>
<p>Beyond these initial registers the compiler uses a simple strategy in register
allocation: if a variable (a parameter or a <code>let</code> binding) is declared, it is
allocated a register based on a stack discipline. Thus, variables are
essentially pushed and popped off the register stack as they come into and out
of scope.</p>
<p>This strategy primarily ensures code simplicity - there is no register
allocation optimization.</p>
<h2><a class="header" href="#cest-tout" id="cest-tout">C'est tout!</a></h2>
<p>That covers the VM and compiler design at an overview level. We've glossed over
a lot of detail but the next chapters will expose the implementation detail.
Get ready!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter-interp-vm-design.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter-interp-vm-impl.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter-interp-vm-design.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter-interp-vm-impl.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
