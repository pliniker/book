<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tagged pointers and symbols - Writing Interpreters in Rust: a Guide</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="part-allocators.html"><strong aria-hidden="true">2.</strong> Allocation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-alignment.html"><strong aria-hidden="true">2.1.</strong> Alignment</a></li><li class="chapter-item expanded "><a href="chapter-blocks.html"><strong aria-hidden="true">2.2.</strong> Obtaining blocks of memory</a></li><li class="chapter-item expanded "><a href="chapter-what-is-alloc.html"><strong aria-hidden="true">2.3.</strong> The type of allocation</a></li></ol></li><li class="chapter-item expanded "><a href="part-stickyimmix.html"><strong aria-hidden="true">3.</strong> An allocator: Sticky Immix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-simple-bump.html"><strong aria-hidden="true">3.1.</strong> Bump allocation</a></li><li class="chapter-item expanded "><a href="chapter-managing-blocks.html"><strong aria-hidden="true">3.2.</strong> Allocating into multiple blocks</a></li><li class="chapter-item expanded "><a href="chapter-allocation-api.html"><strong aria-hidden="true">3.3.</strong> Defining the allocation API</a></li><li class="chapter-item expanded "><a href="chapter-allocation-impl.html"><strong aria-hidden="true">3.4.</strong> Implementing the API</a></li></ol></li><li class="chapter-item expanded "><a href="part-interpreter.html"><strong aria-hidden="true">4.</strong> An interpreter: Eval-rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter-interp-alloc.html"><strong aria-hidden="true">4.1.</strong> Allocating safely</a></li><li class="chapter-item expanded "><a href="chapter-interp-tagged-symbols.html" class="active"><strong aria-hidden="true">4.2.</strong> Tagged pointers and symbols</a></li><li class="chapter-item expanded "><a href="chapter-interp-parser.html"><strong aria-hidden="true">4.3.</strong> Parsing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Interpreters in Rust: a Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#tagged-pointers-and-symbols" id="tagged-pointers-and-symbols">Tagged pointers and symbols</a></h1>
<p>In the previous chapter, we introduced a pointer type <code>ScopedPtr&lt;T&gt;</code>. This
pointer type has compile time knowledge of the type it is pointing at.</p>
<p>In our interpreter we won't always have that. As a dynamic language
interpreter, our compiler won't do type checking. We'll depend on runtime
type identification in our virtual machine.</p>
<p>In Python, for example, the following code does not have compile time
protection against passing in strings:</p>
<pre><code class="language-python">def multiply(a, b):
    return a * b

multiply(&quot;bob&quot;, &quot;alice&quot;)
</code></pre>
<p>This script will result in a runtime error and not a compile time error.
As a dynamically typed interpreter, our language will behave similarly.</p>
<p>For this to work, we need an alternative to <code>ScopedPtr&lt;T&gt;</code> that can represent
all the runtime-visible types so they can be resolved at runtime.
We'll spend some time now inventing some new pointer types to support this.</p>
<h2><a class="header" href="#runtime-type-identification" id="runtime-type-identification">Runtime type identification</a></h2>
<p>The object header can always give us the type id for an object, given a pointer
to the object. However, it requires us to dereference the pointer, do some
arithmetic on the pointer to get the header, then further arithmetic to get
the type id in the header.</p>
<p>Rust itself doesn't have runtime type <em>identification</em> but does have runtime
dispatch through trait objects. In this scheme a pointer consists of two words:
the pointer to the object itself and a second pointer to the vtable where the
concrete object type's methods can be looked up. The generic name for this form
of pointer is a <em>fat</em> pointer.</p>
<p>We could easily use a fat pointer type for runtime type identification
in our interpreter. Each pointer could carry with it an additional word with
the type id in it, or we could even just use trait objects directly!</p>
<p>A dynamically typed language will manage many pointers that must be type
identified at runtime. Carrying around an extra word per pointer is expensive!
A common optimization in many runtimes is to use <a href="1">tagged pointers</a>.</p>
<p>In a pointer to any object on the heap, the least most significant bits turn out
to always be zero due to word or double-word alignment.</p>
<p>On a 64 bit platform, a pointer will be a 64 bit word. Since objects will be
at least word-aligned - a pointer will always be a multiple of 8 - that means
that there are 3 bits that are always 0. On 32 bit platforms, the 2 least
significant bits are always 0.</p>
<pre><code>  64..............48..............32..............16...........xxx
0b1000001111011101101100101010101010010101010011110110101111101000
                                                               / |
                                                              /  |
                                                            unused
</code></pre>
<p>When dereferencing a pointer, these bits must always be zero. But we <em>can</em> use
them in pointers at rest to store a limited type identifier! We'll limit
ourselves to 2 bits of type identifier so as to not complicate our code in
distinguishing between 32 and 64 bit platforms<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Given we'll only have 4 possible types we can id directly from a pointer,
we'll still need to fall back on the object header for types that don't fit
into this range.</p>
<h3><a class="header" href="#tagged-pointer-types" id="tagged-pointer-types">Tagged pointer types</a></h3>
<p>Flipping bits on a pointer directly definitely constitutes a big Unsafe. We'll
need to make a tagged pointer type that will fundamentally be <code>unsafe</code> because
it won't be safe to dereference it. Then we'll need a safe abstraction over
that type to make it safe to dereference.</p>
<p>A type that can represent one of multiple types at runtime is obviously the
<code>enum</code>. We can wrap <code>ScopedPtr&lt;T&gt;</code> possibilities in an <code>enum</code>:</p>
<pre><code class="language-rust ignore">#[derive(Copy, Clone)]
pub enum Value&lt;'guard&gt; {
    Nil,
    Pair(ScopedPtr&lt;'guard, Pair&gt;),
    Symbol(ScopedPtr&lt;'guard, Symbol&gt;),
}
</code></pre>
<p>We've also referenced two new types, <code>Pair</code> and <code>Symbol</code>, that we'll go on to
explain shortly.</p>
<p>You probably noticed that <code>Value</code> is essentially a fat pointer. It is composed
of a set of <code>ScopedPtr&lt;T&gt;</code>s, each of which should only require a single
word, and an enum discriminant integer, which will also, due to alignment,
require a word. We'll end up with a lot more discriminants so at this point,
we can't do tagged pointer trickery, the discriminant value will not fit into
2 bits.</p>
<p>This enum, however, since it wraps <code>ScopedPtr&lt;T&gt;</code> and has the same requirement
for an explicit lifetime, is Safe To Dereference.</p>
<p>But, since this type occupies the same space as a fat pointer, it isn't the type
we want for storing pointers at rest. Let's look at the compact tagged pointer
type now:</p>
<pre><code class="language-rust ignore">#[derive(Copy, Clone)]
pub union TaggedPtr {
    tag: usize,
    number: isize,
    symbol: NonNull&lt;Symbol&gt;,
    pair: NonNull&lt;Pair&gt;,
    object: NonNull&lt;()&gt;,
}
</code></pre>
<p>Here we have a <code>union</code> type, making this an unsafe representation of a pointer.
The <code>tag</code> value will be constrained to the values 0, 1, 2 or 3, which will
determine which of the next four possible members should be accessed. Members
will have to be bit-masked to access their correct values.</p>
<p>These tags and masks are defined as:</p>
<pre><code class="language-rust ignore">const TAG_MASK: usize = 0x3;
pub const TAG_NUMBER: usize = 0x0;
pub const TAG_SYMBOL: usize = 0x1;
pub const TAG_PAIR: usize = 0x2;
pub const TAG_OBJECT: usize = 0x3;
const PTR_MASK: usize = !0x3;
</code></pre>
<p>As you can see, we've allocated a tag for a <code>Symbol</code> type, a <code>Pair</code> type and
one for a numeric type. The fourth member indicates an object whose type
must be determined from the type id in the object header.</p>
<p>Making space for an inline integer type is a not-uncommon use of a tag. It
means any integer arithmetic that fits within the available bits will not
require memory lookups into the heap to retrieve operands. In our case we've
defined the numeric type as an <code>isize</code>. Since the 2 least significant bits
are used for the tag, we will have to right-shift the value by 2 to extract
the correct integer value. We'll go into this implementation in more depth
in a later chapter.</p>
<p>Thus you can see from the choice of embedded tag values, we've optimized for
identifying <code>Pair</code>s and <code>Symbol</code>s and integer math.</p>
<p>Translating between <code>Value</code> and <code>TaggedPtr</code> will be made easier by creating
an intermediate type that represents all types as an enum but doesn't require
a valid lifetime. We can even write a method on our object header to
return this type as the header knows about all runtime types.</p>
<pre><code class="language-rust.ignore">#[derive(Copy, Clone)]
pub enum FatPtr {
    Nil,
    Pair(RawPtr&lt;Pair&gt;),
    Symbol(RawPtr&lt;Symbol&gt;),
}
</code></pre>
<p>In this representation we encapsulate the <code>RawPtr&lt;T&gt;</code> type that the allocator
API gives us.</p>
<h3><a class="header" href="#tagged-pointer-conversion" id="tagged-pointer-conversion">Tagged pointer conversion</a></h3>
<h4><a class="header" href="#fatptr-to-value" id="fatptr-to-value">FatPtr to Value</a></h4>
<p>We can implement <code>From&lt;FatPtr&gt;</code> for <code>TaggedPtr</code> and <code>Value</code>
to convert to the final two possible pointer representations.
Well, not exactly - the function signature
<code>From&lt;FatPtr&gt;::from(ptr: FatPtr) -&gt; Value&lt;'guard&gt;</code> can't provide the <code>'guard</code>
lifetime so we have to implement a similar method that can:</p>
<pre><code class="language-rust ignore">impl FatPtr {
    pub fn as_value&lt;'guard&gt;(&amp;self, guard: &amp;'guard dyn MutatorScope) -&gt; Value&lt;'guard&gt; {
        match self {
            FatPtr::Nil =&gt; Value::Nil,

            FatPtr::Pair(raw_ptr) =&gt; Value::Pair(ScopedPtr::new(guard, raw_ptr.scoped_ref(guard))),

            FatPtr::Symbol(raw_ptr) =&gt; {
                Value::Symbol(ScopedPtr::new(guard, raw_ptr.scoped_ref(guard)))
            }
        }
    }
}
</code></pre>
<h4><a class="header" href="#fatptr-to-taggedptr" id="fatptr-to-taggedptr">FatPtr to TaggedPtr</a></h4>
<p>We will introduce a helper trait and methods to work with tag values and
<code>RawPtr&lt;T&gt;</code> types from the allocator:</p>
<pre><code class="language-rust ignore">pub trait Tagged&lt;T&gt; {
    fn tag(self, tag: usize) -&gt; NonNull&lt;T&gt;;
    fn untag(from: NonNull&lt;T&gt;) -&gt; RawPtr&lt;T&gt;;
}

impl&lt;T&gt; Tagged&lt;T&gt; for RawPtr&lt;T&gt; {
    fn tag(self, tag: usize) -&gt; NonNull&lt;T&gt; {
        unsafe { NonNull::new_unchecked((self.as_word() | tag) as *mut T) }
    }

    fn untag(from: NonNull&lt;T&gt;) -&gt; RawPtr&lt;T&gt; {
        RawPtr::new((from.as_ptr() as usize &amp; PTR_MASK) as *const T)
    }
}
</code></pre>
<p>This will help convert from <code>RawPtr&lt;T&gt;</code> values in <code>FatPtr</code> to the <code>NonNull&lt;T&gt;</code>
based <code>TaggedPtr</code> discriminants. Because <code>TaggedPtr</code> is a <code>union</code> type and
because it has to apply the appropriate tag value inside the pointer itself, we
can't work with it as ergnomically as an <code>enum</code>. We'll create some more helper
functions for instantiating <code>TaggedPtr</code>s appropriately:</p>
<pre><code class="language-rust ignore">impl TaggedPtr {
    pub fn nil() -&gt; TaggedPtr {
        TaggedPtr { tag: 0 }
    }

    pub fn number(value: isize) -&gt; TaggedPtr {
        TaggedPtr {
            number: (((value as usize) &lt;&lt; 2) | TAG_NUMBER) as isize,
        }
    }

    pub fn symbol(ptr: RawPtr&lt;Symbol&gt;) -&gt; TaggedPtr {
        TaggedPtr {
            symbol: ptr.tag(TAG_SYMBOL),
        }
    }

    fn pair(ptr: RawPtr&lt;Pair&gt;) -&gt; TaggedPtr {
        TaggedPtr {
            pair: ptr.tag(TAG_PAIR),
        }
    }
}
</code></pre>
<p>Finally, we can use the above methods to implement <code>From&lt;FatPtr</code> for <code>TaggedPtr</code>:</p>
<pre><code class="language-rust ignore">impl From&lt;FatPtr&gt; for TaggedPtr {
    fn from(ptr: FatPtr) -&gt; TaggedPtr {
        match ptr {
            FatPtr::Nil =&gt; TaggedPtr::nil(),
            FatPtr::Number(value) =&gt; TaggedPtr::number(value),
            FatPtr::Symbol(raw) =&gt; TaggedPtr::symbol(raw),
            FatPtr::Pair(raw) =&gt; TaggedPtr::pair(raw),
        }
    }
}
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>There are other pointer tagging schemes, notably the use of &quot;spare&quot; NaN
bit patterns in 64 bit floating point values. Further, <em>which</em> types are
best represented by the tag bits is highly language dependent. Some languages
use them for garbage collection information while others may use them for
still other types hidden from the language user. In the interest of clarity,
we'll stick to a simple scheme.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter-interp-alloc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter-interp-parser.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter-interp-alloc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter-interp-parser.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
